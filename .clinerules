# GitHub MCP Server Project Rules

## Project Structure
- Follow src/ layout pattern for all Python MCP servers
- Keep operations modular and separated by domain (issues, repos, etc.)
- Maintain clear separation between common utilities and domain operations
- Use __init__.py files to expose clean public APIs

## Build and Environment
- Use uv for dependency management and virtual environments
- Build with `uv build --no-build-isolation` flag
- Always specify requires-python in pyproject.toml
- Keep dependencies in virtual environment for isolation

## MCP Configuration
- Use direct venv Python interpreter in MCP settings:
  ```json
  {
    "command": "/path/to/project/.venv/bin/python",
    "args": ["-m", "package_name"]
  }
  ```
- Avoid using uvx/uv run in MCP settings to prevent dependency resolution issues
- Always include necessary environment variables (e.g., GITHUB_PERSONAL_ACCESS_TOKEN)

## Development Patterns
- Use Pydantic models for request/response validation
- Keep operations synchronous for reliability
- Follow consistent error handling patterns using custom exceptions
- Document all public functions and classes thoroughly

## Testing
- Test MCP tools using MCP Inspector during development:
  ```bash
  npx @modelcontextprotocol/inspector uv run github-mcp-server
  ```
- Use MCP Inspector's Web UI to experiment with available tools
- Verify tool operations with real GitHub repositories
- Test both success and error cases
- Document example payloads that work

## Documentation
- Keep memory bank up to date with all significant changes
- Document all implementation lessons in active_context.md
- Include example configurations and usage patterns
- Maintain clear next steps and progress tracking

## Documentation
- PyGithub documentation available in docs/PyGithub/
- API reference in docs/PyGithub/api/
- Examples in docs/PyGithub/examples/
- Guides in docs/PyGithub/guides/

## Known Patterns
1. Tool Registration:
   ```python
   @mcp.tool()
   def tool_name(params: ParamsModel) -> dict:
       """Tool docstring with clear Args and Returns."""
       # Implementation
       return {"content": [{"type": "text", "text": json.dumps(result, indent=2)}]}
   ```

2. PyGithub Integration:
   ```python
   try:
       client = GitHubClient.get_instance()
       repository = client.get_repo(f"{owner}/{repo}")
       result = repository.operation(...)  # PyGithub operation
       return convert_object(result)  # Convert to our schema
   except GithubException as e:
       # GitHubClient handles exception
       raise
   ```

3. Object Conversion:
   ```python
   def convert_object(obj: PyGithubObject) -> Dict[str, Any]:
       """Convert PyGithub object to our schema."""
       return {
           "field": obj.field,
           "nested": convert_nested(obj.nested),
           "datetime": obj.datetime.isoformat() if obj.datetime else None,
       }
   ```

4. Error Handling:
   ```python
   try:
       result = api_operation()
       return create_tool_response(result)
   except GitHubError as e:
       return create_tool_response(str(e), is_error=True)
   ```

5. Resource Organization:
   - Common utilities in common/
   - API operations in operations/
   - Types and models in common/types.py
   - Error definitions in common/errors.py
   - GitHub client in common/github.py
   - Object converters in common/converters.py

## Troubleshooting
- If MCP server fails to start, verify venv Python path in settings
- For dependency errors, ensure all requirements are installed in venv
- For GitHub API errors, check token permissions and validity
- For build errors, use --no-build-isolation flag with uv build
- When using MCP Inspector, ensure GITHUB_PERSONAL_ACCESS_TOKEN is set in environment

## Debugging
- Check github_mcp_server.log for detailed error logs
- Log file contains all API interactions and error traces
- Both file and console logging enabled
- Log file is created in the project root directory
- Log format includes timestamps and module names for tracing
